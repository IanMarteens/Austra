<?xml version="1.0" encoding="utf-8"?>
<topic id="1800e13a-baf2-48f8-aefa-746082fe23df" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>The most important data type in AUSTRA is the <newTerm>time series</newTerm>: a sorted collection of pairs date/value.</para>
    </introduction>
    <section address="Section1">
      <title>Time series come from external sources</title>
      <content>
        <para>Since time series represents data from the real world, most of the times, time series come from persistent variables, that can be stored in an external file or database, and may be periodically updated, either by AUSTRA or by another process.</para>
      </content>
      <sections>
        <section address="addInfo">
          <title>Additional information in series</title>
          <content>
            <para>Since one of the goals of AUSTRA is to deal with financial time series, there is a number of optional properties that can be stored in a series:</para>
            <definitionTable>
			  <definedTerm>Name</definedTerm>
			  <definition><para>The name of the series is the name that is used by the parser to locate a series. For this reason, the series' name must be a valid identifier.</para></definition>
			  <definedTerm>Ticker</definedTerm>
			  <definition><para>However, it's frequent for series to be identified by traders by their tickers, which is the name assigned by the provider of the series. A ticker is not necessarily a valid identifier, so we provide two different fields, one for the name and the second for a ticker. Tickers can be empty.</para></definition>
			  <definedTerm><codeEntityReference qualifyHint="false">T:Austra.Library.Frequency</codeEntityReference></definedTerm>
			  <definition><para>Each series has an associated frequency, which can be daily, weekly, biweekly, monthly, bimonthly, quarterly, semestral, yearly, or undefined. The library, at run time, checks that both operands in a binary operation have always the same frequency.</para></definition>
			  <definedTerm><codeEntityReference qualifyHint="false">T:Austra.Library.SeriesType</codeEntityReference></definedTerm>
			  <definition><para>In addition, each series has a type that can be either <codeInline>Raw</codeInline>, <codeInline>Rets</codeInline>, <codeInline>Logs</codeInline>, <codeInline>MixedRets</codeInline>, or <codeInline>Mixed</codeInline>.</para></definition>
            </definitionTable>
          </content>
        </section>
        <section>
          <title>Series versus vectors</title>
          <content>
            <para><link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">Vector</link> operations check, at run time, that the operands have the same length. The
same behaviour would be hard to enforce for series. On one hand, each series can
have a different first available date. On the other hand, even series with the same
frequency could have reported values at different days of the week or the month,
and still, it could be interesting to mix them.</para>
			<para>So, the rules for mixing two series in an operation are:</para>
			<list class="bullet">
			  <listItem><para>They must have the same frequency, and their frequencies are checked at runtime.</para></listItem>
			  <listItem><para>However, they may have different lengths. If this is the case, the shorter length is chosen for the result.</para></listItem>
			  <listItem><para>The points of the series are aligned according to their most recent points.</para></listItem>
			  <listItem><para>The list of dates assigned to the result series is chosen arbitrarily from the first operand.</para></listItem>
			</list>
          </content>
        </section>
        <section address="seriesCtors">
          <title>Class methods</title>
          <content>
            <para>There is only one constructor for series:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>series::new</codeInline></para></entry>
 		    	<entry><para>Creates a linear combination of series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Combine(Austra.Library.DVector,Austra.Library.Series[])</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
			<para>The first parameter of <codeInline>series::new</codeInline> must be a vector of weights, and from that point on, a list of series must be included. This class method creates a linear combination of series. The length of the weights
vector can be equal to the number of series or the number of series plus one. For instance:</para>
			<code language="Austra">
series([0.1, 0.9], aapl, msft);
<markup><font color="DarkGreen">-- The above code is equivalent to this:</font></markup>
0.1 * aapl + 0.9 * msft
			</code>
			<para>If we add another item to the vector, it will act as an independent term:</para>
			<code language="Austra">
series([0.5, 0.1, 0.9], aapl, msft);
<markup><font color="DarkGreen">-- The above code is equivalent to this:</font></markup>
0.5 + 0.1 * aapl + 0.9 * msft
			</code>
          </content>
        </section>
        <section address="serieProperties">
          <title>Series properties</title>
          <content>
            <para>These properties are applied to instances of series:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>acf</codeInline></para></entry>
 		    	<entry><para>The AutoCorrelation Function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.ACF</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amax</codeInline></para></entry>
 		    	<entry><para>Gets the maximum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.AbsMax</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amin</codeInline></para></entry>
 		    	<entry><para>Gets the minimum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.AbsMin</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>count</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Count</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fft</codeInline></para></entry>
 		    	<entry><para>Gets the Fast Fourier Transform of the values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Fft</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first point in the series (the oldest one). See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.First</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fit</codeInline></para></entry>
 		    	<entry><para>Gets a vector with two coefficients for a linear fit. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Fit</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>kurt</codeInline></para></entry>
 		    	<entry><para>Get the kurtosis. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Kurtosis</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>kurtp</codeInline></para></entry>
 		    	<entry><para>Get the kurtosis of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.PopulationKurtosis</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last point in the series (the newest one). See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Last</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linearFit</codeInline></para></entry>
 		    	<entry><para>Gets a line fitting the original series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.LinearFit</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>logs</codeInline></para></entry>
 		    	<entry><para>Gets the logarithmic returns. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.AsLogReturns</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Get the maximum value from the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Maximum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Mean</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Get the minimum value from the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Minimum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>movingRet</codeInline></para></entry>
 		    	<entry><para></para>Gets the moving monthly/yearly return. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.MovingRet</codeEntityReference>.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ncdf</codeInline></para></entry>
 		    	<entry><para>Gets the percentile of the last value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.NCdf</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>pacf</codeInline></para></entry>
 		    	<entry><para>The Partial AutoCorrelation Function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.PACF</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>perc</codeInline></para></entry>
 		    	<entry><para>Gets the percentiles of the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Percentiles</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>random</codeInline></para></entry>
 		    	<entry><para>Creates a random series from a normal distribution. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Random</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>rets</codeInline></para></entry>
 		    	<entry><para>Gets the linear returns. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.AsReturns</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>skew</codeInline></para></entry>
 		    	<entry><para>Gets the skewness. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Skewness</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>skewp</codeInline></para></entry>
 		    	<entry><para>Gets the skewness of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.PopulationSkewness</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets all statistics in one call. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Stats</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>std</codeInline></para></entry>
 		    	<entry><para>Gets the standard deviation. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.StandardDeviation</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stdp</codeInline></para></entry>
 		    	<entry><para>Gets the standard deviation of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.PopulationStandardDeviation</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Sum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>type</codeInline></para></entry>
 		    	<entry><para>Gets the type of the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Type</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>var</codeInline></para></entry>
 		    	<entry><para>Gets the variance. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Variance</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>varp</codeInline></para></entry>
 		    	<entry><para>Gets the variance of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.PopulationVariance</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>values</codeInline></para></entry>
 		    	<entry><para>Gets the underlying vector of values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Series`1.Values</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
          </content>
        </section>
        <section address="seriesMethods">
          <title>Series methods</title>
          <content>
            <para>These are the methods supported by time series:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>all</codeInline></para></entry>
 		    	<entry><para>Checks if all items satisfy a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.All(System.Func{System.Double,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>any</codeInline></para></entry>
 		    	<entry><para>Checks if exists an item satisfying a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Any(System.Func{System.Double,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ar</codeInline></para></entry>
 		    	<entry><para>Calculates the autoregression coefficients for a given order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.AutoRegression(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>arModel</codeInline></para></entry>
 		    	<entry><para>Creates a full AR(p) model. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.ARModel(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>autocorr</codeInline></para></entry>
 		    	<entry><para>Gets the autocorrelation given a lag. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.AutoCorrelation(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>corr</codeInline></para></entry>
 		    	<entry><para>Gets the correlation with a series given as a parameter. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Correlation(Austra.Library.Series{`0})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>correlogram</codeInline></para></entry>
 		    	<entry><para>Gets all autocorrelations up to a given lag. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Correlogram(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>cov</codeInline></para></entry>
 		    	<entry><para>Gets the covariance with another given series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.Covariance(Austra.Library.Series{`0})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ewma</codeInline></para></entry>
 		    	<entry><para>Calculates an Exponentially Weighted Moving Average. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.EWMA(System.Double)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>filter</codeInline></para></entry>
 		    	<entry><para>Filters points by values or dates. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Filter(System.Func{Austra.Library.Point{Austra.Library.Dates.Date},System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>indexOf</codeInline></para></entry>
 		    	<entry><para>Returns the index where a value is stored. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.IndexOf(System.Double)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linear</codeInline></para></entry>
 		    	<entry><para>Gets the regression coefficients given a list of series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.LinearModel(Austra.Library.Series[])</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linearModel</codeInline></para></entry>
 		    	<entry><para>Creates a full linear model given a list of series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.FullLinearModel(Austra.Library.Series[])</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ma</codeInline></para></entry>
 		    	<entry><para>Calculates the moving average coefficients for a given order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.MovingAverage(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>maModel</codeInline></para></entry>
 		    	<entry><para>Creates a full MA(q) model. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.MAModel(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>map</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the series with a lambda. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Map(System.Func{System.Double,System.Double})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>movingAvg</codeInline></para></entry>
 		    	<entry><para>Calculates a Simple Moving Average. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.MovingAvg(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>movingNcdf</codeInline></para></entry>
 		    	<entry><para>Calculates a Moving Normal Percentile. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.MovingNcdf(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>movingStd</codeInline></para></entry>
 		    	<entry><para>Calculates a Moving Standard Deviation. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.MovingStd(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ncdf</codeInline></para></entry>
 		    	<entry><para>Gets the normal percentil for a given value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series`1.NCdf(System.Double)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets monthly statistics for a given date. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.GetSliceStats(Austra.Library.Dates.Date)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>zip</codeInline></para></entry>
 		    	<entry><para>Combines two series using a lambda function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.Series.Zip(Austra.Library.Series,System.Func{System.Double,System.Double,System.Double})</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
          </content>
        </section>
        <section address="seriesOps">
          <title>Operators</title>
          <content>
            <para>These operators can be used with time series:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>+</codeInline></para></entry>
 		    	  <entry><para>Adds two series, or a series and a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>-</codeInline></para></entry>
 		    	  <entry><para>Subtracts two series, or a series and a scalar. Also works as the unary negation.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>*</codeInline></para></entry>
 		    	  <entry><para>Multiplies a series and a scalar for scaling values.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>/</codeInline></para></entry>
 		    	  <entry><para>Divides a series by a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>.*</codeInline></para></entry>
 		    	  <entry><para>Pointwise series multiplication.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>./</codeInline></para></entry>
 		    	  <entry><para>Pointwise series division.</para></entry>
		  		</row>
			  </table>
          </content>
        </section>
      </sections>
    </section>
    <section address="seriesIdx">
      <title>Indexing and slicing</title>
      <content>
		<para>Points in a series can be access using an index expression between brackets:</para>
		<code language="Austra">
aapl[0];
aapl[appl.count - 1].value = aapl.last.value;
aapl[^2] = aapl[aapl.count - 2]
		</code>
		<para>Series also supports extracting a slice using dates or indexes. In the first case, you must provide two dates inside brackets, separated by a range operator (<codeInline>..</codeInline>), and one of the bounds can be omitted:</para>
		<code language="Austra">
aapl[jan20..jan21];
aapl[jan20..15@jan21];
aapl[jan20..];
aapl[..jan21]
		</code>
		<para>The upper bound is excluded from the result, as usual. Date arguments in a series index do not support the caret (<codeInline>^</codeInline>) operator for relative indexes. When using numerical indexes in a slice, the behaviour is similar to the one of vectors:</para>
		<code language="Austra">
aapl[1..aapl.count - 1].count = aapl[1..^1].count
		</code>
      </content>
    </section>
    <section address="seriesFit">
      <title>Linear fitting</title>
      <content>
		<para>When you face a time series for the first time, the first thing you want is to decompose the series in all its identifiable components. The series may be the sum of a linear or quadratic process, it may have seasonal variations or any kind of period-ic variation, it may show signs of a stochastic process such as an autoregressive or moving average process and, of course, there will be almost always a random noise in the raw data.</para>
		<para>The most easily identifiable component is perhaps a linear trend in the data. Look at the chart of this raw series with monthly sampling:</para>
		<mediaLink><image placement="near" xlink:href="s003"/></mediaLink>
		<para>If you apply the <codeInline>fit</codeInline> method to this series, the answer will be two numbers in a real vector:</para>
		<code language="Austra">
aaa.fit
<markup><font color="DarkGreen">-- This is the answer:</font><br/>
<font color="#404040">ans ∊ ℝ(2)<br/>
0.134716  -97404.4</font></markup>
		</code>
		<para>The first number in the vector is the slope, and the second number is the intercept, that is, the value when the argument of the corresponding line is zero. If you wanted to look at the inferred line, you could execute the <codeInline>linearFit</codeInline> property on <codeInline>aaa</codeInline>, which creates a series with the same date, but with values from the fitted line. You can also subtract <codeInline>aaa.linearFit</codeInline> from <codeInline>aaa</codeInline>, to see the part of the data that cannot be explained by a simple line model:</para>
		<mediaLink><image placement="near" xlink:href="s004"/></mediaLink>
		<para>Austra uses Ordinary Least Squares (OLS) to find the coefficients of the fitting line.</para>
      </content>
    </section>
    <section address="seriesLinear">
      <title>Linear models</title>
      <content>
		<para>If your data cannot be easily explained using a simple line, you could try another approach: explaining a series as a linear combination of other existing series. Let us say that we want to explain the <codeInline>aaa</codeInline> series using three other series. This is the formula we need:</para>
		<code language="Austra">
aaa.linearModel(aab, aac, aad)
		</code>
		<para>An instance of the <codeInline>LinearModel</codeInline> class is created, and this is how the Austra Desktop application shows it:</para>
		<mediaLink><image placement="near" xlink:href="s005"/></mediaLink>
		<para>The most important data is contained in the first line of the answer:</para>
		<code language="Austra">
aaa=-803.12+0.858*aab+1875.52*aac+0.308*aad
		</code>
		<para>That is how the series to be explained can be approximated with the other three predicting series. Coefficients are calculated to minimize the OLS of the difference between the prediction and the original.</para>
		<para>The second line give us the <legacyItalic>t-statistics</legacyItalic> for the relevance of each coefficient. Note, for example, that the most relevant coefficient is the one corresponding to the <codeInline>aab</codeInline> series, even though the coefficient for <codeInline>aac</codeInline> is greater. The reason is that values from <codeInline>aac</codeInline> are smaller than values from <codeInline>aab</codeInline>. The next line gives us the <codeInline>R2</codeInline> statistics, also known as <legacyItalic>goodness of fit</legacyItalic>, which is the quotient between the explained variance and total variance. The closer <codeInline>R2</codeInline> is to one, the better the explanation is.</para>
		<para>Finally, the application shows a chart including the original and the predicted series.</para>
		<para>In case you only need the coefficients of the model, you can call the <codeInline>linear</codeInline> method on <codeInline>aaa</codeInline>, using the same parameters as before. <codeInline>linear</codeInline> just returns a vector with the coefficients used in the model.</para>
      </content>
    </section>
    <section address="stats">
      <title>Statistics on time series</title>
      <content>
		<para>A fair share of the properties and methods implemented by series has to do with statistics, either of the whole series or of partial samples from the series. Most of these properties and methods are shared with real vectors and sequences, for obvious reasons.</para>
		<para>The next few sections deal with time series features that computes statistics for a time series.</para>
      <sections>
        <section address="statsAccum">
          <title>Accumulators</title>
          <content>
			<para>The <codeInline>stats</codeInline> property returns an object from the C#’s <codeEntityReference qualifyHint="false">T:Austra.Library.Stats.Accumulator</codeEntityReference> class that holds statistics on all samples from the series.</para>
			<para>The <codeEntityReference qualifyHint="false">T:Austra.Library.Stats.Accumulator</codeEntityReference> class defined by the Austra library, implements a running accumulator that calculates and updates the most important statistics estimators as we keep adding values from a dataset, using the well-known Welford algorithm. Our implementation of Welford’s algorithm takes advantage of SIMD instructions from the CPU, when available. Since it is a fast implementation, the result returned by the <codeInline>stat</codeInline> property from a series is always computed when the time series is created. Persistent series are created when the Austra Desktop application starts up, or when a series is retrieved the first time from an external service or database. This way, you can always call <codeInline>stats</codeInline> without concerns about efficiency, and the same is valid on any property derived from the running accumulator.</para>
			<para>Most of the properties of stats are also available as direct properties of the series, for convenience. They are:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>count</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Count</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>kurt</codeInline></para></entry>
 		    	<entry><para>Get the kurtosis. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Kurtosis</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>kurtp</codeInline></para></entry>
 		    	<entry><para>Get the kurtosis of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.PopulationKurtosis</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Get the maximum value from the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Maximum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Mean</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Get the minimum value from the series. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Minimum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>skew</codeInline></para></entry>
 		    	<entry><para>Gets the skewness. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Skewness</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>skewp</codeInline></para></entry>
 		    	<entry><para>Gets the skewness of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.PopulationSkewness</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>std</codeInline></para></entry>
 		    	<entry><para>Gets the standard deviation. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.StandardDeviation</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stdp</codeInline></para></entry>
 		    	<entry><para>Gets the standard deviation of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.PopulationStandardDeviation</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>var</codeInline></para></entry>
 		    	<entry><para>Gets the variance. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.Variance</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>varp</codeInline></para></entry>
 		    	<entry><para>Gets the variance of the population. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.Stats.Accumulator.PopulationVariance</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
			<para>Remember that most of all these properties are just estimators, and that their accuracy depends on the number of samples. Skewness and kurtosis, for example, needs more than a thousand samples for an approximate ballpark estimation, at least, according to my own experience.</para>
			<mediaLink><image placement="near" xlink:href="acc001"/></mediaLink>
			<para>One nice property about running accumulators is that you can combine two of them easily and efficiently using the plus operator:</para>
			<code language="Austra">
aaa.stats + aab.stats
			</code>
			<para>A <codeInline>stats</codeInline> property is also implemented by real and integer <link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">vectors</link> and <link xlink:href="d1757dd1-7bbd-4d90-88b9-cc034c5ad326">sequences</link>.</para>
          </content>
        </section>
        <section address="statsAcf">
          <title>Autocorrelation and partial autocorrelation</title>
          <content>
			<para>There are two important diagnostic functions on series: the autocorrelation function, also known by the acronym ACF, and the partial autocorrelation function, also known as PACF.</para>
			<para>The ACF is defined as the Pearson correlation between a signal and a delayed copy of the signal. The argument of the function is the delay between the samples and, since we are dealing with discrete signals, the type of the argument is an integer value.</para>
			<para>There are formulas that work better with stationary series, that is, series with uniform statistical properties, widely speaking. Most financial series are not stationary, when the sampling time is long enough, as we will see soon. Our algorithm does not assume stationarity and is based on the <externalLink>
<linkText>Wiener-Khinchin theorem</linkText>
<linkUri>https://mathworld.wolfram.com/Wiener-KhinchinTheorem.html</linkUri>
<linkTarget>_blank</linkTarget>
</externalLink>, that relates the autocorrelation function with the power spectral density via the Fourier Transform. Internally, Austra calculates a Fast Fourier Transform on a padded version of the series, using the next available power of two size for speed.</para>
			<para>The Partial Autocorrelation Function, or PACF, is closely related but must not be confused with the ACF. The PACF measures the direct correlation between two lags, without accounting for the transitive effect of any intermediate lags. Our PACF implementation calculates the ACF as a prerequisite, and then performs the Levinson-Durbin algorithm on the ACF to remove those spurious effects from the lags in-between.</para>
          </content>
        </section>
        <section address="statsAr">
          <title>Autoregressive models</title>
          <content>
			<para>The autoregressive model is one of the simplest stochastic models that can generate a time series. If we denote as <math>x(t)</math> the value of a series at a time or step <math>t</math>, an autoregressive model of order <math>p</math> is a process generated by this formula:</para>
			<mediaLink><image placement="near" xlink:href="ar002"/></mediaLink>
			<para>The <math>ε(t)</math> term is a random value taken from any distribution, not necessarily a standard one. It is only required that the mean of <math>ε(t)</math> be zero. If the order of the model, <math>p</math>, is zero, what remains is just white noise. And things start getting interesting when <math>p&gt;0</math>, because each term start been influenced by a subset of the preceding terms in the series.</para>
			<para>The easiest way to generate an autoregressive model for testing is using class methods from real sequences. What series provide are methods for estimating parameters for an autoregressive model, assuming that the series has been generated by such a model. The <codeInline>arModel</codeInline> method estimates coefficients and includes some useful statistics with the output. The <codeInline>ar</codeInline> method is a leaner version of <codeInline>arModel</codeInline> that only returns coefficients. Finally, you can use the <codeInline>pacf</codeInline> property to check if an autoregressive process would be a good guess about how the series has been generated.</para>
			<para>Let us take as example our good-old <codeInline>aaa</codeInline> series:</para>
			<mediaLink><image placement="near" xlink:href="s001"/></mediaLink>
			<para>This is not a stationary series, and it looks more like a random walk. But an autoregressive process can yield random walks instead of stationary series when the sum of the coefficients is high enough. We will start by calculating the Partial Autocorrelation Function of the samples we have. Theory says that partial autocorrelations for an autoregressive model falls to zero after a few lags. And that is just what we see when we plot the full PACF of <codeInline>aaa</codeInline>:</para>
			<mediaLink><image placement="near" xlink:href="pacf001"/></mediaLink>
			<para>The return type of properties like <codeInline>acf</codeInline> and <codeInline>pacf</codeInline> is <codeInline>series&lt;int&gt;</codeInline>: instead of the usual pairs containing date/value, here we return pairs containing lag/value. Unfortunately, the control used for the chart does not have all the whistles and bells we would want. So, lets manually zoom on the first lags, to see what is happening.</para>
			<para>Since series stores their values in reverse order, what we really want is a slice from the end of a series, so we will evaluate this formula:</para>
			<code language="Austra">
aaa.pacf[^20..^0]
			</code>
			<para>And this is the new chart we get:</para>
			<mediaLink><image placement="near" xlink:href="pacf2"/></mediaLink>
			<para>The first value of both the ACF and the PACF functions corresponds always to the lag zero, so it is always one. The value for the lag one is near one, and then, all the rest of the partial autocorrelations are negligible. We will bet that we can model the series with an autoregressive model of degree 1, and we are pretty sure that the coefficient will be high enough to generate a random walk instead of a stationary series. We will use the more nuanced method <codeInline>arModel</codeInline> to get as information as possible:</para>
			<code language="Austra">
aaa.arModel(1)
			</code>
			<para>And voilà, here we have the estimated model:</para>
			<mediaLink><image placement="near" xlink:href="ar001"/></mediaLink>
			<para>As we already suspected, the coefficient is greater than unity. The <codeInline>r2</codeInline> property of the model is the same <legacyItalic>goodness of fit</legacyItalic> we have already seen with linear models. It is the quotient of the explained variance over the total variance, and it is high enough for the model to be considered a good one.</para>
			<para>The chart plots both the original series and the “predicted” one. As a word of caution, don’t be fooled by the word “prediction”: what we are forecasting is just one step forward, assuming the historically attested levels. It would be impossible, as it stands to reason, to generate the whole series from an initial level and the autoregressive law.</para>
	  		<alert class="note">
			  <para>Austra estimates coefficients for AR models using the so-called Yule-Walker equations.</para>
	  		</alert>
          </content>
        </section>
        <section address="statsMa">
          <title>Moving Average models</title>
          <content>
            <para>Another common process that generates a time series is the algorithm known as Moving Average. A Moving Average process of order <math>q</math>, often referred as <math>MA(q)</math>, is defined by the following formula:</para>
			<mediaLink><image placement="near" xlink:href="ma001"/></mediaLink>
			<para>This is a very different beast that the autoregressive models we have already seen. All the <math>ε(i)</math> terms still refer to random variables centred around zero. We also have a new term, <math>μ</math>, which is interpreted as the mean of the series. What makes different an MA model from an AR one is that what is propagated to successive steps is not the actual value at a past time, but the error term introduced in a previous step.</para>
			<para>Pure Moving Average series are stationary series. Since I do not have a good real candidate at hand, I will use a transformed series as the source of the MA example. I have an <codeInline>aac</codeInline> series, and I will take its linear returns as my original samples. Even then, the resulting series is not a stationary one, so the match will not be perfect. This is how I get the linear returns from a time series:</para>
			<code language="Austra">
aac.rets
			</code>
			<para>And this is the corresponding chart:</para>
			<mediaLink><image placement="near" xlink:href="s006"/></mediaLink>
			<para>For MA series, we must use the ACF instead of the PACF. These are the fifty first lags of the ACF:</para>
			<mediaLink><image placement="near" xlink:href="acf001"/></mediaLink>
			<para>This time, the cutoff is not as clear as before. Let us start by trying an MA(2) model:</para>
			<mediaLink><image placement="near" xlink:href="ma002"/></mediaLink>
			<para>It could have been worse. The <codeInline>r2</codeInline> statistics is nothing to write home about. Note that, this time, we also have the <math>μ</math> parameter for the mean of the series. We could keep rising the number of the degrees of the model for a better match, but we would soon meet diminished returns. Remember that the original series was not a stationary one.</para>
	  		<alert class="note">
			  <para>MA models are way harder to estimate than the simpler AR model. The depend on past “errors”, which are not directly observable, but must be inferred from the samples.</para>
	  		</alert>
		  </content>
        </section>>
      </sections>
      </content>
    </section>
    <relatedTopics>
      <codeEntityReference qualifyHint="false">T:Austra.Library.Series</codeEntityReference>
	  <link xlink:href="90cb2899-abcf-4ebe-b96a-8cfac1b2809f">Code definitions</link>
      <link xlink:href="8b381718-bf08-4762-a51b-1516af27bef2">Local variables</link>
      <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">Lambda functions</link>
      <link xlink:href="e22b4127-e7a9-47ca-bd1c-7ac81efcc051">Arithmetic</link>
      <link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">Vectors</link>
      <link xlink:href="d1757dd1-7bbd-4d90-88b9-cc034c5ad326">Sequences</link>
      <link xlink:href="e9d3be4d-ac7d-4b8e-b892-c47a5a0beb49">Matrices</link>
      <link xlink:href="95cad3a9-e319-4787-a66b-596e34e6ddd6">List comprehensions</link>
      <link xlink:href="008dce7e-55cd-4c37-997b-b0463d7c24d0">Splines</link>
    </relatedTopics>
  </developerConceptualDocument>
</topic>