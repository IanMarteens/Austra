<?xml version="1.0" encoding="utf-8"?>
<topic id="1800e13a-baf2-48f8-aefa-746082fe23df" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>The most important data type in AUSTRA is the <newTerm>time series</newTerm>: a sorted collection of pairs date/value.</para>
    </introduction>
    <!-- Add one or more top-level section elements.  These are collapsible.
         If using <autoOutline />, add an address attribute to identify it
         and specify a title so that it can be jumped to with a hyperlink. -->
    <section address="Section1">
      <title>Time series come from external sources</title>
      <content>
        <para>Since time series represents data from the real world, most of the times, time series come from persistent variables, that can be stored in an external file or database, and may be periodically updated, either by AUSTRA or by another process.</para>
      </content>
      <sections>
        <section>
          <title>Additional information in series</title>
          <content>
            <para>Since one of the goals of AUSTRA is to deal with financial time series, there is a number of optional properties that can be stored in a series:</para>
            <definitionTable>
			  <definedTerm>Name</definedTerm>
			  <definition><para>The name of the series is the name that is used by the parser to locate a series. For this reason, the series' name must be a valid identifier.</para></definition>
			  <definedTerm>Ticker</definedTerm>
			  <definition><para>However, it's frequent for series to be identified by traders by their tickers, which is the name assigned by the provider of the series. A ticker is not necessarily a valid identifier, so we provide two different fields, one for the name and the second for a ticker. Tickers can be empty.</para></definition>
			  <definedTerm><codeEntityReference qualifyHint="false">T:Austra.Library.Frequency</codeEntityReference></definedTerm>
			  <definition><para>Each series has an associated frequency, which can be daily, weekly, biweekly, monthly, bimonthly, quarterly, semestral, yearly, or undefined. The library, at run time, checks that both operands in a binary operation have always the same frequency.</para></definition>
			  <definedTerm><codeEntityReference qualifyHint="false">T:Austra.Library.SeriesType</codeEntityReference></definedTerm>
			  <definition><para>In addition, each series has a type that can be either <codeInline>Raw</codeInline>, <codeInline>Rets</codeInline>, <codeInline>Logs</codeInline>, <codeInline>MixedRets</codeInline>, or <codeInline>Mixed</codeInline>.</para></definition>
            </definitionTable>
          </content>
        </section>
        <section>
          <title>Series versus vectors</title>
          <content>
            <para><link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">Vector</link> operations check, at run time, that the operands have the same length. The
same behaviour would be hard to enforce for series. On one hand, each series can
have a different first available date. On the other hand, even series with the same
frequency could have reported values at different days of the week or the month,
and still, it could be interesting to mix them.</para>
			<para>So, the rules for mixing two series in an operation are:</para>
			<list class="bullet">
			  <listItem><para>They must have the same frequency, and their frequencies are checked at runtime.</para></listItem>
			  <listItem><para>However, they may have different lengths. If this is the case, the shorter length is chosen for the result.</para></listItem>
			  <listItem><para>The points of the series are aligned according to their most recent points.</para></listItem>
			  <listItem><para>The list of dates assigned to the result series is chosen arbitrarily from the first operand.</para></listItem>
			</list>
          </content>
        </section>
        <section>
          <title>Class methods</title>
          <content>
            <para>There is only one constructor for series:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>series::new</codeInline></para></entry>
 		    	<entry><para>Creates a linear combination of series.</para></entry>
		  	  </row>
			</table>
			<para>The first parameter of <codeInline>series::new</codeInline> must be a vector of weights, and from that point on, a list of series must be included. This class method creates a linear combination of series. The length of the weights
vector can be equal to the number of series or the number of series plus one. For instance:</para>
			<code language="Austra">
series([0.1, 0.9], aapl, msft);
<markup><font color="DarkGreen">-- The above code is equivalent to this:</font></markup>
0.1 * aapl + 0.9 * msft
			</code>
			<para>If we add another item to the vector, it will act as an independent term:</para>
			<code language="Austra">
series([0.5, 0.1, 0.9], aapl, msft);
<markup><font color="DarkGreen">-- The above code is equivalent to this:</font></markup>
0.5 + 0.1 * aapl + 0.9 * msft
			</code>
          </content>
        </section>
        <section>
          <title>Series properties</title>
          <content>
            <para>These properties are applied to instances of series:</para>
          </content>
        </section>
      </sections>
    </section>
    <relatedTopics>
      <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">Lambda functions</link>
      <link xlink:href="e22b4127-e7a9-47ca-bd1c-7ac81efcc051">Arithmetic</link>
      <link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">Vectors</link>
      <link xlink:href="d1757dd1-7bbd-4d90-88b9-cc034c5ad326">Sequences</link>
    </relatedTopics>
  </developerConceptualDocument>
</topic>