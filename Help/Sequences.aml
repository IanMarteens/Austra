<?xml version="1.0" encoding="utf-8"?>
<topic id="d1757dd1-7bbd-4d90-88b9-cc034c5ad326" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>Sequences provides most of the operations from real and complex vectors, but avoiding the storage. Sequences are similar to enumerable types in C# with LINQ, and are a requisite for any functional language.</para>
    </introduction>
    <section address="Section1">
      <title>Sequences as light vectors</title>
      <content>
        <para>Let's say we want to calculate factorials. AUSTRA is a functional language, so we don't have explicit loops. We could, however, do this with a vector:</para>
        <code language="Austra">
        vec(10, i => i + 1).prod
        </code>
        <para>The above code works fine, but it forces the library to allocate one array of ten items. This is the alternative, using a sequence:</para>
        <code language="Austra">
        seq(1, 10).prod
        </code>
        <para>Since the sequence's values are generated only by demand, there's no need for the internal storage.</para>
      </content>
      <sections>
          <section address="SubSection1">
              <title>Sequence constructors</title>
              <content>
                  <para>This code fragment shows some of the available constructors for sequences:</para>
		          <code language="Austra">
seq(1, 10);       <markup><font color="DarkGreen">-- Numbers from 1 to 10.</font></markup>
seq(10, 1);       <markup><font color="DarkGreen">-- The inverted sequence.</font></markup>
seq::new(1, 10);  <markup><font color="DarkGreen">-- ::new was omitted before.</font></markup>
seq(0, τ, 128);   <markup><font color="DarkGreen">-- A uniform grid with 128 intervals.</font></markup>
seq(v);           <markup><font color="DarkGreen">-- A sequence from a vector.</font></markup>
seq::random(10);  <markup><font color="DarkGreen">-- A sequence with 10 random values.</font></markup>
seq::nrandom(10)  <markup><font color="DarkGreen">-- A sequence with 10 Gaussian random values.</font></markup>
				  </code>
				  <para><codeInline>seq::nrandom</codeInline> is overloaded so you can specify either a variance for the sequence, keeping a zero mean, or a variance and a vector of <newTerm>autoregressive</newTerm> coefficients:</para>
		          <code language="Austra">
<markup><font color="DarkGreen">-- A thousand samples from a normal distribution with variance = 2.</font></markup>
seq::nrandom(1000, 2);
<markup><font color="DarkGreen">-- An autoregressive (AR) process of order three.</font></markup>
seq::nrandom(1000, 1, [0.1, 0.05, 0.01]);
<markup><font color="DarkGreen">-- An moving average (MA) process of order three.</font></markup>
seq::nrandom(1000, 1, 0, [0.1, 0.05, 0.01])
				  </code>
				  <para>The MA overload (see <see cref="M:Austra.Library.DoubleSequence.NormalRandom(System.Int32,System.Double,System.Double,Austra.Library.Vector)" />) uses one additional parameter before coefficients, and it is interpreted as the independent term, or mean, of the process.</para>
				  <para>You can materialize the content of a sequence as a vector using the <codeInline>toVector</codeInline> property:</para>
		          <code language="Austra">
seq::random(10).toVector
				  </code>
              </content>
          </section>
          <section address="SubSection2">
              <title>Methods and properties</title>
              <content>
                  <para>These are the methods that can be used with a sequence:</para>
		<table>
 		  <row>
 		    <entry><para><codeInline>all</codeInline></para></entry>
 		    <entry><para>Checks if all items in the sequence satisfy a predicate. See <see cref="M:Austra.Library.DoubleSequence.All(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>any</codeInline></para></entry>
 		    <entry><para>Checks if there is a item in the sequence satisfying a predicate. See <see cref="M:Austra.Library.DoubleSequence.Any(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>arModel</codeInline></para></entry>
 		    <entry><para>Estimates an AR(p) model from the sequence. See <see cref="M:Austra.Library.DoubleSequence.ARModel(System.Int32)" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>filter</codeInline></para></entry>
 		    <entry><para>Returns items of the original sequence satisfying a predicate. See <see cref="M:Austra.Library.DoubleSequence.Filter(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>map</codeInline></para></entry>
 		    <entry><para>Transforms items with the help of a lambda function. See <see cref="M:Austra.Library.DoubleSequence.Map(System.Func{System.Double,System.Double})" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>reduce</codeInline></para></entry>
 		    <entry><para>Conflates all values in a sequence using a lambda. See <see cref="M:Austra.Library.DoubleSequence.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>zip</codeInline></para></entry>
 		    <entry><para>Combines two sequences using a lambda function. See <see cref="M:Austra.Library.DoubleSequence.Zip(Austra.Library.DoubleSequence,System.Func{System.Double,System.Double,System.Double})" />.</para></entry>
		  </row>
		</table>
		<para>Properties are methods without parameters, that can be called without parentheses. These are the supported properties:</para>
		<table>
 		  <row>
 		    <entry><para><codeInline>distinct</codeInline></para></entry>
 		    <entry><para>Select unique values in the sequence, with no predefined order. See <see cref="M:Austra.Library.DoubleSequence.Distinct" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>fft</codeInline></para></entry>
 		    <entry><para>Calculates a Fast Fourier Transform. See <see cref="M:Austra.Library.DoubleSequence.Fft" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>first</codeInline></para></entry>
 		    <entry><para>Gets the first term of the sequence. See <see cref="M:Austra.Library.DoubleSequence.First" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>last</codeInline></para></entry>
 		    <entry><para>Gets the last term of the sequence. See <see cref="M:Austra.Library.DoubleSequence.Last" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>length</codeInline></para></entry>
 		    <entry><para>Gets the number of elements in the sequence. See <see cref="M:Austra.Library.DoubleSequence.Length" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>max</codeInline></para></entry>
 		    <entry><para>Get the maximum value in the sequence. See <see cref="M:Austra.Library.DoubleSequence.Max" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>min</codeInline></para></entry>
 		    <entry><para>Get the minimum value in the sequence. See <see cref="M:Austra.Library.DoubleSequence.Min" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>plot</codeInline></para></entry>
 		    <entry><para>Plots the sequence. See <see cref="M:Austra.Library.DoubleSequence.Plot" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>prod</codeInline></para></entry>
 		    <entry><para>Multiplies all values in the sequence. See <see cref="M:Austra.Library.DoubleSequence.Product" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>sort</codeInline></para></entry>
 		    <entry><para>Sorts values in ascending order. See <see cref="M:Austra.Library.DoubleSequence.Sort" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>sortDesc</codeInline></para></entry>
 		    <entry><para>Sorts values in descending order. See <see cref="M:Austra.Library.DoubleSequence.SortDescending" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>stats</codeInline></para></entry>
 		    <entry><para>Gets all statistic moments of the sequence. See <see cref="M:Austra.Library.DoubleSequence.Stats" />.</para></entry>
		  </row>		  
 		  <row>
 		    <entry><para><codeInline>sum</codeInline></para></entry>
 		    <entry><para>Sums all values in the sequence. See <see cref="M:Austra.Library.DoubleSequence.Sum" />.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>toVector</codeInline></para></entry>
 		    <entry><para>Materializes the sequence into a vector. See <see cref="M:Austra.Library.DoubleSequence.ToVector" />.</para></entry>
		  </row>
		</table>
              </content>
          </section>
          <section address="SubSection2">
              <title>Sequence operators</title>
              <content>
                  <para>Sequence operators mimics most of vector's operators.</para>
		          <code language="Austra">
seq(1, 10) * seq(10, 1)  <markup><font color="DarkGreen">-- The dot product.</font></markup>
				  </code>
                  <para>For instance, simple operators can be used to change the underlying distribution of a random sequence.</para>
		          <code language="Austra">
seq::random(100) * 2 - 1;
<markup><font color="DarkGreen">-- Check the moments of the above distribution.</font></markup>
(seq::random(100) * 2 - 1).stats
				  </code>
				  <alert class="note">
				  <para>Unary operators for sequences could, in theory, be implemented using <codeInline>map</codeInline>, and binary operators can also be written using <codeInline>zip</codeInline>.</para>
				  <para>However, in most cases, having an explicit operator results in a faster implementation. It is most evident for sequences backed by a vector, but it also happens for other kinds of sequences. For instance, when a range or grid sequence is negated, you can implement the result using another range or grid sequence.</para>
				  </alert>
              </content>
          </section>
          <section address="SubSection2">
              <title>Delayed execution</title>
              <content>
                  <para>Sequence are modeled after .NET LINQ enumerables, and so many other functional libraries. One of the most interesting features of these libraries is <newTerm>delayed execution</newTerm>.</para>
                  <para>Applying a method or an operator on a sequence does not means that it will automatically scan the sequence values. Let's start with a simple example:</para>
		          <code language="Austra">
-seq(1, 1000)
				  </code>
                  <para>The above code first creates a sequence that will enumerate numbers from 1 to 1000. Creating the sequence means creating a small instance of an internal class that can be called later to yield the values in the sequence. The unary minus, however, take that sequence generator and returns another generator that yields values in descending order, from the interval <math>[-10, -1]</math>. It does not forces yet the sequence enumeration. Actually, enumeration takes place as the last operation, as you hit F5 in the AUSTRA desktop, as the application needs to print the values created by the expression. The same would happen with this expression, that plots the sequence as a series:</para>
		          <code language="Austra">
-seq(1, 1000).plot
				  </code>
				  <para>It is the <codeInline>plot</codeInline> method the trigger which starts the internal loop for generating all the values. You could even intercalate another method call before the plot, without triggering enumeration:</para>
		          <code language="Austra">
<markup><font color="DarkGreen">-- Sort the negated values in ascending order.</font></markup>
-seq(1, 1000).sort.plot;
<markup><font color="DarkGreen">-- Square values, select multiples of three and sort descending.</font></markup>
seq(1, 1000).map(x => x^2).filter(x => x % 3 = 0).sortDesc.plot;
<markup><font color="DarkGreen">-- Methods like sum, prod, any, all or first can also trigger evaluation.</font></markup>
seq(1, 100).filter(x => x % 2 = 0).map(x => x^2).sum
				  </code>
              </content>
          </section>
      </sections>
    </section>
    <relatedTopics>
      <link xlink:href="8b381718-bf08-4762-a51b-1516af27bef2">Local variables</link>
      <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">Lambda functions</link>
      <link xlink:href="e22b4127-e7a9-47ca-bd1c-7ac81efcc051">Arithmetic</link>
      <link xlink:href="1800e13a-baf2-48f8-aefa-746082fe23df">Time series</link>
      <link xlink:href="aae4328b-9ead-40dc-b407-54e8d0614cd5">Vectors</link>
    </relatedTopics>
  </developerConceptualDocument>
</topic>