<?xml version="1.0" encoding="utf-8"?>
<topic id="aae4328b-9ead-40dc-b407-54e8d0614cd5" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>AUSTRA provides double-precision vectors, identified by the class <codeInline>vec</codeInline>, complex double-precision vectors, <codeInline>cvec</codeInline>, and vectors of integer, <codeInline>ivec</codeInline>. All these data types are implemented using dense storage.</para>
    </introduction>
    <section address="Section1">
      <title>Real vectors</title>
      <content>
        <para>A vector is constructed by listing its components inside brackets:</para>
        <code language="Austra">
[1, 2, 3, 4]
		</code>
		<para>Commas are mandatory for separating items, and white space and line feeds are always ignored.</para>
		<para>Bracket lists can be also used to concatenate the content of several vectors, and you can add scalars to the mix:</para>
		<code language="Austra">
<markup><b>let</b></markup> v1=[1, 2], v2=[3, 4];
<markup><font color="DarkGreen">-- Returns a vector with 4 items.</font></markup>
[v1, v2];
<markup><font color="DarkGreen">-- This also is accepted:</font></markup>
[[1, 2], v2];
<markup><font color="DarkGreen">-- Scalars can also be added.</font></markup>
[0, v1, pi, v2, tau];
		</code>
		<sections>
		  <section address="vecclass">
		    <title>Class methods</title>
		    <content>
			  <para>Vectors can also be created using these class methods:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>vec::new</codeInline></para></entry>
 		    	  <entry><para>Overloaded constructor (see below).</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::ones</codeInline></para></entry>
 		    	  <entry><para>Creates a vector filled with ones.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::random</codeInline></para></entry>
 		    	  <entry><para>Creates a vector with random values from a uniform distribution.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::nrandom</codeInline></para></entry>
 		    	  <entry><para>Creates a vector with random values from a normal standard distribution.</para></entry>
		  		</row>
			  </table>
			  <para>These are the overloads supported by <codeInline>vec::new</codeInline>:</para>
        	  <code language="Austra">
<markup><font color="DarkGreen">-- Creates a vector with 10 items, all of them zeros.</font><br/>
<b><font color="DarkCyan">vec::</font></b></markup>new(10);
<markup><font color="DarkGreen">-- Remember that ::new can be omitted!</font></markup>
vec(10);
<markup><font color="DarkGreen">-- Creates a vector like [1 2 3 4 5 6 7 8 9 10]</font></markup>
vec(10, i => i + 1)
			  </code>
			  <para>The last example shows how to create a vector using a <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">lambda function</link> parameter. This is a more sophisticated example of using a lambda to initialize items in a vector:</para>
        	  <code language="Austra">
<markup><font color="DarkGreen">-- Mimics a periodic function.</font></markup>
vec(1024, i => sin(i*pi/512) + 0.8*cos(i*pi/256))
			  </code>
        	  <para><codeInline>vec::new</codeInline> can also be used to create a linear combination of vectors:</para>
        	  <code language="Austra">
vec([0.5, 0.1, 0.7, 0.2], v1, v2, v3)
			  </code>
			  <para>The first parameter contains weights, and the remaining parameters are the vectors that will be linearly combined. If there is an extra value in the weights, as in the example, it is used as an independent term. The above expression is equivalent to this one:</para>
        	  <code language="Austra">
0.5 + 0.1 * v1 + 0.7 * v2 + 0.2 * v3
			  </code>
			  <para>Please note that the parser can detect some code patterns and optimize expressions automatically. For instance, for vectors, the parser recognizes these patterns:</para>
        	  <code language="Austra">
vector1 * scalar + vector2;
scalar * vector1 + vector2;
scalar1 * vector1 + scalar2 * vector2;
			  </code>
			  <para>Both these expressions are reduced to calls to one of the overloads of the method <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.MultiplyAdd(Austra.Library.DVector,Austra.Library.DVector)</codeEntityReference>. These methods are internally optimized to use a single temporary buffer, instead of the two buffers of a naïve implementation, and both of them use FMA fused operations when available. Of course, the method underlying the above presented <codeInline>vec::new</codeInline> constructor is even better optimized and runs several faster than even the optimized versions of lineal composition.</para>
		    </content>
		  </section>
		  <section>
		    <title>Vector properties</title>
		    <content>
		      <para>Properties and methods or vectors are very similar to the ones from series. As a rule, almost all code in series that do not need to take dates into account, is implemented via the corresponding vector code, which is heavily optimized and hardware-accelerated. These are the properties supported by a vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>abs</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with absolute values. See <see cref="M:Austra.Library.DVector.Abs" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>acf</codeInline></para></entry>
 		    	<entry><para>The AutoCorrelation Function. See <see cref="M:Austra.Library.DVector.ACF" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amax</codeInline></para></entry>
 		    	<entry><para>Gets the maximum of the absolute values. See <see cref="M:Austra.Library.DVector.AMax" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amin</codeInline></para></entry>
 		    	<entry><para>Gets the minimum of the absolute values. See <see cref="M:Austra.Library.DVector.AMin" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <see cref="M:Austra.Library.DVector.Distinct" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fft</codeInline></para></entry>
 		    	<entry><para>Gets the Fast Fourier Transform of the values. See <see cref="M:Austra.Library.DVector.Fft" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <see cref="P:Austra.Library.DVector.First" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <see cref="P:Austra.Library.DVector.Last" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <see cref="P:Austra.Library.DVector.Length" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Get the maximum value from the vector. See <see cref="M:Austra.Library.DVector.Maximum" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values in the vector. See <see cref="M:Austra.Library.DVector.Mean" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Get the minimum value from the vector. See <see cref="M:Austra.Library.DVector.Minimum" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>norm</codeInline></para></entry>
 		    	<entry><para></para>Gets the Pythagorean norm of the vector. See <see cref="M:Austra.Library.DVector.Norm" />.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>plot</codeInline></para></entry>
 		    	<entry><para>Shows the vector in a chart. See <see cref="M:Austra.Library.DVector.Plot" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <see cref="M:Austra.Library.DVector.Product" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <see cref="M:Austra.Library.DVector.Reverse" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sort</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with its items sorted. See <see cref="M:Austra.Library.DVector.Sort" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sortDescending</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with its items sorted in descending order. See <see cref="M:Austra.Library.DVector.SortDescending" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqr</codeInline></para></entry>
 		    	<entry><para>Gets the scalar product of the vector with itself. See <see cref="M:Austra.Library.DVector.Squared" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqrt</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the square root of each item. See <see cref="M:Austra.Library.DVector.Sqrt" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets all statistics in one call. See <see cref="M:Austra.Library.DVector.Stats" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <see cref="M:Austra.Library.DVector.Sum" />.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="vecmeths">
		    <title>Vector methods</title>
		    <content>
		      <para>These are the methods supported by a vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>all</codeInline></para></entry>
 		    	<entry><para>Checks if all items satisfy a lambda predicate. See <see cref="M:Austra.Library.DVector.All(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>any</codeInline></para></entry>
 		    	<entry><para>Checks if exists an item satisfying a lambda predicate. See <see cref="M:Austra.Library.DVector.Any(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ar</codeInline></para></entry>
 		    	<entry><para>Gets the autoregression coefficients for a given <codeInline>p</codeInline>. See <see cref="M:Austra.Library.DVector.AutoRegression(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>arModel</codeInline></para></entry>
 		    	<entry><para>Creates a full AR(p) model. See <see cref="M:Austra.Library.DVector.ARModel(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>autocorr</codeInline></para></entry>
 		    	<entry><para>Gets the autocorrelation given a lag. See <see cref="M:Austra.Library.DVector.AutoCorrelation(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>correlogram</codeInline></para></entry>
 		    	<entry><para>Gets all autocorrelations up to a given lag. See <see cref="M:Austra.Library.DVector.Correlogram(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>filter</codeInline></para></entry>
 		    	<entry><para>Filters items by value. See <see cref="M:Austra.Library.DVector.Filter(System.Func{System.Double,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>find</codeInline></para></entry>
 		    	<entry><para>Similar to <codeInline>filter</codeInline>, but returns a sequence of the indexes. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Find(System.Double)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>indexOf</codeInline></para></entry>
 		    	<entry><para>Returns the first index where a value is stored. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.IndexOf(System.Double,System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linear</codeInline></para></entry>
 		    	<entry><para>Gets the regression coefficients given a list of vectors. See <see cref="M:Austra.Library.DVector.LinearModel(Austra.Library.DVector[])" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linearModel</codeInline></para></entry>
 		    	<entry><para>Creates a full linear model from a list of vectors. See <see cref="M:Austra.Library.DVector.FullLinearModel(Austra.Library.DVector[])" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ma</codeInline></para></entry>
 		    	<entry><para>Estimates coefficients for an MA(q) model. See <see cref="M:Austra.Library.DVector.MovingAverage(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>maModel</codeInline></para></entry>
 		    	<entry><para>Creates a full MA(q) model. See <see cref="M:Austra.Library.DVector.MAModel(System.Int32)" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>map</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items in a vector. See <see cref="M:Austra.Library.DVector.Map(System.Func{System.Double,System.Double})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reduce</codeInline></para></entry>
 		    	<entry><para>Reduces all items in a vector to a single value. See <see cref="M:Austra.Library.DVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>zip</codeInline></para></entry>
 		    	<entry><para></para>Combines two vectors using a lambda function. See <see cref="M:Austra.Library.DVector.Zip(Austra.Library.DVector,System.Func{System.Double,System.Double,System.Double})" />.</entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="vecOperators">
		    <title>Vector operators</title>
		    <content>
			  <para>Real-valued vectors supports the basic repertoire of operators:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>+</codeInline></para></entry>
 		    	  <entry><para>Adds two vectors, or a vector and a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>-</codeInline></para></entry>
 		    	  <entry><para>Subtracts two vectors, or a vector and a scalar. Also works as the unary negation.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>*</codeInline></para></entry>
 		    	  <entry><para>Multiplying two vectors represents the inner vector product, returning a number. A vector multiplied by a scalar is a vector scaling operation.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>/</codeInline></para></entry>
 		    	  <entry><para>Divides a vector by a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>.*</codeInline></para></entry>
 		    	  <entry><para>Pointwise vector multiplication.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>./</codeInline></para></entry>
 		    	  <entry><para>Pointwise vector division.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>^</codeInline></para></entry>
 		    	  <entry><para>Outer product for two vectors, returning a matrix.</para></entry>
		  		</row>
			  </table>
			  <para>The outer product of vectors <math>x[i]</math> and <math>y[i]</math> returns the matrix with components <math>m[i,j]=x[i]*y[j]</math>. This expression call:</para>
			  <code language="Austra">
[1,2,3]^[4,5,6]
			  </code>
			  <para>returns this matrix:</para>
			  <code language="Austra Desktop">
ans ∊ ℝ(3⨯3)
 4   5   6
 8  10  12
12  15  18
			  </code>
		    </content>
		  </section>
		</sections>
      </content>
    </section>
    <section address="cvecs">
      <title>Complex vectors</title>
      <content>
		<para>There's no special syntax for complex vector literals, but complex vectors can be easily created using the <codeInline>cvec::new</codeInline> class method and one or two vector constructors:</para>
        <code language="Austra">
<markup><b><font color="DarkCyan">cvec::</font></b></markup>new([1 2 3 4], [4 3 2 1]);
<markup><font color="DarkGreen">-- ::new can be omitted.</font></markup>
cvec([1 2 3 4], [4 3 2 1])
		</code>
		<para>These class methods are available for creating complex vectors:</para>
		<table>
 		  <row>
 		      <entry><para><codeInline>cvec::new</codeInline></para></entry>
			  <entry><para>Overloaded constructor (see below).</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>cvec::random</codeInline></para></entry>
 		    <entry><para>Creates a complex vector with random values from a uniform distribution.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>cvec::nrandom</codeInline></para></entry>
 		    <entry><para>Creates a complex vector with random values from a normal standard distribution.</para></entry>
		  </row>
		</table>
		<para>These are the overloads supported by <codeInline>cvec::new</codeInline>:</para>
        <code language="Austra">
<markup><font color="DarkGreen">-- Creates a complex vector with 10 zeros.</font></markup>
cvec(10);
<markup><font color="DarkGreen">-- Creates a complex vector from one real vector.</font></markup>
cvec([1, 2, 3]);
<markup><font color="DarkGreen">-- Creates a complex vector from two real vectors.</font></markup>
cvec([1, 2, 3], [3, 2, 1]);
<markup><font color="DarkGreen">-- Creates a complex vector with a lambda function.</font></markup>
cvec(10, i => polar(2π*i/10));
<markup><font color="DarkGreen">-- The lambda function includes access to the complex vector.</font></markup>
cvec(100, (i, v) => polar(2π*i/10) - 0.01 * i * v{i-1})
	    </code>
	    <sections>
		  <section address="cvecprop">
		    <title>Complex vector properties</title>
		    <content>
		      <para>These are the properties supported by a complex vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>amax</codeInline></para></entry>
 		    	<entry><para>Gets the maximum of the absolute values. See <see cref="M:Austra.Library.CVector.AbsMax" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amin</codeInline></para></entry>
 		    	<entry><para>Gets the minimum of the absolute values. See <see cref="M:Austra.Library.CVector.AbsMin" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <see cref="M:Austra.Library.CVector.Distinct" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fft</codeInline></para></entry>
 		    	<entry><para>Gets the Fast Fourier Transform of the values. See <see cref="M:Austra.Library.CVector.Fft" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <see cref="P:Austra.Library.CVector.First" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>imag</codeInline></para></entry>
 		    	<entry><para>Gets the imaginary components as a vector. See <see cref="P:Austra.Library.CVector.Imaginary" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <see cref="P:Austra.Library.CVector.Last" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <see cref="P:Austra.Library.CVector.Length" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>magnitudes</codeInline></para></entry>
 		    	<entry><para>Gets magnitudes as a vector. See <see cref="M:Austra.Library.CVector.Magnitudes" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values in the vector. See <see cref="M:Austra.Library.CVector.Mean" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>norm</codeInline></para></entry>
 		    	<entry><para></para>Gets the Pythagorean norm of the vector. See <see cref="M:Austra.Library.CVector.Norm" />.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>phases</codeInline></para></entry>
 		    	<entry><para></para>Gets phases as a vector. See <see cref="M:Austra.Library.CVector.Phases" />.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>plot</codeInline></para></entry>
 		    	<entry><para>Shows the vector in a chart. See <see cref="M:Austra.Library.CVector.Plot" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <see cref="M:Austra.Library.CVector.Product" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>real</codeInline></para></entry>
 		    	<entry><para>Gets the real components as a vector. See <see cref="P:Austra.Library.CVector.Real" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <see cref="M:Austra.Library.CVector.Reverse" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqr</codeInline></para></entry>
 		    	<entry><para>Gets the scalar product of the vector with itself. See <see cref="M:Austra.Library.CVector.Squared" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <see cref="M:Austra.Library.CVector.Sum" />.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  	<section aaddress="cvecmeth">
		      <title>Complex vector methods</title>
		    	<content>
		      	  <para>These are the methods supported by a complex vector instance:</para>
				  <table>
 		  	  		<row>
 		    		  <entry><para><codeInline>all</codeInline></para></entry>
 		    		  <entry><para>Checks if all items satisfy a lambda predicate. See <see cref="M:Austra.Library.CVector.All(System.Func{System.Numerics.Complex,System.Boolean})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>any</codeInline></para></entry>
 		    		  <entry><para>Checks if exists an item satisfying a lambda predicate. See <see cref="M:Austra.Library.CVector.Any(System.Func{System.Numerics.Complex,System.Boolean})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>filter</codeInline></para></entry>
 		    		  <entry><para>Filters items by value. See <see cref="M:Austra.Library.CVector.Filter(System.Func{System.Numerics.Complex,System.Boolean})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>find</codeInline></para></entry>
 		    		  <entry><para>Similar to <codeInline>filter</codeInline>, but returns a sequence of the indexes. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Find(System.Numerics.Complex)</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>indexOf</codeInline></para></entry>
 		    		  <entry><para>Returns the first index where a value is stored. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.IndexOf(System.Numerics.Complex)</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>map</codeInline></para></entry>
 		    		  <entry><para>Pointwise transformation of the items in a vector. See <see cref="M:Austra.Library.CVector.Map(System.Func{System.Numerics.Complex,System.Numerics.Complex})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>mapReal</codeInline></para></entry>
 		    		  <entry><para>Pointwise transformation of the items in a vector. Returns a real vector. See <see cref="M:Austra.Library.CVector.MapReal(System.Func{System.Numerics.Complex,System.Double})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>reduce</codeInline></para></entry>
 		    		  <entry><para>Reduces all items in a vector to a single value. See <see cref="M:Austra.Library.CVector.Reduce(System.Numerics.Complex,System.Func{System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex})" />.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>zip</codeInline></para></entry>
 		    		  <entry><para></para>Combines two vectors using a lambda function. See <see cref="M:Austra.Library.CVector.Zip(Austra.Library.CVector,System.Func{System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex})" />.</entry>
		  	  		</row>
				  </table>
			</content>
		  </section>
		  <section address="cvecOperators">
		    <title>Complex vector operators</title>
		    <content>
			  <para>Complex vectors supports the same operators as real-valued operators, with the exception of the outer product <codeInline>^</codeInline>. On the other hand, they add support for complex vector conjugation using a unary suffix operator:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>'</codeInline></para></entry>
 		    	  <entry><para>Unary suffix operator for complex vector conjugation.</para></entry>
		  		</row>
			  </table>
			  <para>Complex vector conjugation inverts the sign of each imaginary component in the vector. The inner product of two complex vectors actually conjugates the second vector operand.</para>
		    </content>
		  </section>
	    </sections>
	  </content>
    </section>
    <section address="ivecs">
      <title>Integer vectors</title>
      <content>
        <para>Integer vectors are also supported, using the <codeInline>ivec</codeInline> class.</para>
	    <table>
  		  <row>
    	    <entry><para><codeInline>ivec::new</codeInline></para></entry>
    	    <entry><para>Overloaded constructor.</para></entry>
  		  </row>
  		  <row>
    	    <entry><para><codeInline>ivec::ones</codeInline></para></entry>
    	    <entry><para>Creates a vector filled with ones.</para></entry>
  		  </row>
  		  <row>
    	    <entry><para><codeInline>ivec::random</codeInline></para></entry>
    	    <entry><para>Creates a vector with random values from a uniform distribution.</para></entry>
  		  </row>
	    </table>
        <para><codeInline>ivec::random</codeInline> has three overloaded variants:</para>
		<code language="Austra">
<markup><font color="DarkGreen">-- Ten items. Values between <codeInline>0</codeInline> and <codeInline>int.MaxValue - 1</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(10);
<markup><font color="DarkGreen">-- Values between <codeInline>0</codeInline> and <codeInline>999</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(10, 1000);
<markup><font color="DarkGreen">-- Values between <codeInline>-10</codeInline> and <codeInline>9</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(-10, 10)
		</code>
		<sections>
		  <section address="ivecprop">
		    <title>Integer vector properties</title>
		    <content>
		    <para>Integer vectors support these properties:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>abs</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with absolute values. See <see cref="M:Austra.Library.NVector.Abs" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <see cref="M:Austra.Library.NVector.Distinct" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <see cref="P:Austra.Library.NVector.First" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <see cref="P:Austra.Library.NVector.Last" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <see cref="P:Austra.Library.NVector.Length" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Gets the maximum value from the vector. See <see cref="M:Austra.Library.NVector.Maximum" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Gets the minimum values from the vector. See <see cref="M:Austra.Library.NVector.Minimum" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <see cref="M:Austra.Library.NVector.Product" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <see cref="M:Austra.Library.NVector.Reverse" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sort</codeInline></para></entry>
 		    	<entry><para>Sorts the vector in ascending order. See <see cref="M:Austra.Library.NVector.Sort" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sortDesc</codeInline></para></entry>
 		    	<entry><para>Sorts the vector in descending order. See <see cref="M:Austra.Library.NVector.SortDescending" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets all statistics in one call. See <see cref="M:Austra.Library.NVector.Stats" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <see cref="M:Austra.Library.NVector.Sum" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>toVector</codeInline></para></entry>
 		    	<entry><para>Converts the integer vector into a double vector. See <see cref="M:Austra.Library.NVector.ToVector" />.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="ivecmth">
		    <title>Integer vector methods</title>
		    <content>
		    <para>These are the methods for integer vectors:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>all</codeInline></para></entry>
 		    	<entry><para>Checks if all items satisfy a lambda predicate. See <see cref="M:Austra.Library.NVector.All(System.Func{System.Int32,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>any</codeInline></para></entry>
 		    	<entry><para>Checks if exists an item satisfying a lambda predicate. See <see cref="M:Austra.Library.NVector.Any(System.Func{System.Int32,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>filter</codeInline></para></entry>
 		    	<entry><para>Filters items by value. See <see cref="M:Austra.Library.NVector.Filter(System.Func{System.Int32,System.Boolean})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>map</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items in another integer vector. See <see cref="M:Austra.Library.NVector.Map(System.Func{System.Int32,System.Int32})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mapReal</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items into a real vector. See <see cref="M:Austra.Library.NVector.MapReal(System.Func{System.Int32,System.Double})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reduce</codeInline></para></entry>
 		    	<entry><para>Reduces all items in a vector to a single integer value. See <see cref="M:Austra.Library.NVector.Reduce(System.Int32,System.Func{System.Int32,System.Int32,System.Int32})" />.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>zip</codeInline></para></entry>
 		    	<entry><para></para>Combines two integer vectors using a lambda function. See <see cref="M:Austra.Library.NVector.Zip(Austra.Library.NVector,System.Func{System.Int32,System.Int32,System.Int32})" />.</entry>
		  	  </row>
			</table>
			</content>
		  </section>
		</sections>
      </content>
    </section>
    <section address="vecidx">
      <title>Indexing and slicing</title>
      <content>
		<para>Individual values from vectors are accessed using its position, starting from zero, inside brackets:</para>
		<code language="Austra">
vec[0];
vec[vec.length - 1]
		</code>
		<para>A segment or slice can be extracted as another vector by using this notation:</para>
		<code language="Austra">
vec[1..vec.length - 1]
		</code>
		<para>The above expression removes the first and the last element from a vector. The upper bound is excluded.</para>
		<para>The caret (<codeInline>^</codeInline>) can be used in indexes and segments, to count positions from the end. For instance, this expression returns the next to last item of a vector:</para>
		<code language="Austra">
vec[^1]
		</code>
		<para>These equalities hold:</para>
		<code language="Austra">
vec[1..^1] = vec[1..vec.length - 1];
vec[^5..^2].length = 3
		</code>
		<para>Vectors and series also support safe indexers. With normal indexers, like <codeInline>v[1000]</codeInline>, an out-of-range reference throws an exception and interrupts the evaluation of the
		formula. If braces are used instead of brackets, and out-of-range reference returns 0.0 and it is considered as a valid use. For instance, the following expression returns zero:</para>
		<code language="Austra">
[1, 2, 3, 4]{1000}
		</code>
		<para>Safe indexers are useful when used inside lambda functions. This expression creates a vector holding the first 30 Fibonacci numbers:</para>
		<code language="Austra">
		vec(30, (i, v) => max(1, v{i-1} + v{i-2}))
		</code>
      </content>
    </section>
    <relatedTopics>
      <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">Lambda functions</link>
      <link xlink:href="e22b4127-e7a9-47ca-bd1c-7ac81efcc051">Arithmetic</link>
      <link xlink:href="1800e13a-baf2-48f8-aefa-746082fe23df">Time series</link>
      <link xlink:href="d1757dd1-7bbd-4d90-88b9-cc034c5ad326">Sequences</link>
      <link xlink:href="e9d3be4d-ac7d-4b8e-b892-c47a5a0beb49">Matrices</link>
      <codeEntityReference qualifyHint="false">T:Austra.Library.DVector</codeEntityReference>
      <codeEntityReference qualifyHint="false">T:Austra.Library.CVector</codeEntityReference>
      <codeEntityReference qualifyHint="false">T:Austra.Library.NVector</codeEntityReference>
    </relatedTopics>
  </developerConceptualDocument>
</topic>