<?xml version="1.0" encoding="utf-8"?>
<topic id="aae4328b-9ead-40dc-b407-54e8d0614cd5" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>AUSTRA provides double-precision vectors, identified by the class <codeInline>vec</codeInline>, complex double-precision vectors, <codeInline>cvec</codeInline>, and vectors of integer, <codeInline>ivec</codeInline>. All these data types are implemented using dense storage.</para>
    </introduction>
    <section address="Section1">
      <title>Real vectors</title>
      <content>
        <para>A vector is constructed by listing its components inside brackets:</para>
        <code language="Austra">
[1, 2, 3, 4]
		</code>
		<para>Commas are mandatory for separating items, and white space and line feeds are always ignored.</para>
		<para>Bracket lists can be also used to concatenate the content of several vectors, and you can add scalars to the mix:</para>
		<code language="Austra">
<markup><b>let</b></markup> v1=[1, 2], v2=[3, 4];
<markup><font color="DarkGreen">-- Returns a vector with 4 items.</font></markup>
[v1, v2];
<markup><font color="DarkGreen">-- This also is accepted:</font></markup>
[[1, 2], v2];
<markup><font color="DarkGreen">-- Scalars can also be added.</font></markup>
[0, v1, pi, v2, tau];
		</code>
		<sections>
		  <section address="vecclass">
		    <title>Class methods</title>
		    <content>
			  <para>Vectors can also be created using these class methods:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>vec::new</codeInline></para></entry>
 		    	  <entry><para>Overloaded constructor (see <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.#ctor(System.Int32)</codeEntityReference>
 		    	  ).</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::ones</codeInline></para></entry>
 		    	  <entry><para>Creates a vector filled with ones.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::random</codeInline></para></entry>
 		    	  <entry><para>Creates a vector with random values from a uniform distribution.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>vec::nrandom</codeInline></para></entry>
 		    	  <entry><para>Creates a vector with random values from a normal standard distribution.</para></entry>
		  		</row>
			  </table>
			  <para>These are the overloads supported by <codeInline>vec::new</codeInline>:</para>
        	  <code language="Austra">
<markup><font color="DarkGreen">-- Creates a vector with 10 items, all of them zeros.</font><br/>
<b><font color="DarkCyan">vec::</font></b></markup>new(10);
<markup><font color="DarkGreen">-- Remember that ::new can be omitted!</font></markup>
vec(10);
<markup><font color="DarkGreen">-- Creates a vector like [1 2 3 4 5 6 7 8 9 10]</font></markup>
vec(10, i => i + 1)
			  </code>
			  <para>The last example shows how to create a vector using a <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">lambda function</link> parameter. This is a more sophisticated example of using a lambda to initialize items in a vector:</para>
        	  <code language="Austra">
<markup><font color="DarkGreen">-- Mimics a periodic function.</font></markup>
vec(1024, i => sin(i*pi/512) + 0.8*cos(i*pi/256))
			  </code>
        	  <para><codeInline>vec::new</codeInline> can also be used to create a linear combination of vectors:</para>
        	  <code language="Austra">
vec([0.5, 0.1, 0.7, 0.2], v1, v2, v3)
			  </code>
			  <para>The first parameter contains weights, and the remaining parameters are the vectors that will be linearly combined. If there is an extra value in the weights, as in the example, it is used as an independent term. The above expression is equivalent to this one:</para>
        	  <code language="Austra">
0.5 + 0.1 * v1 + 0.7 * v2 + 0.2 * v3
			  </code>
			  <para>Please note that the parser can detect some code patterns and optimize expressions automatically. For instance, for vectors, the parser recognizes these patterns:</para>
        	  <code language="Austra">
vector1 * scalar + vector2;
scalar * vector1 + vector2;
scalar1 * vector1 + scalar2 * vector2;
			  </code>
			  <para>All these expressions are reduced to calls to one of the overloads of either <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.MultiplyAdd(Austra.Library.DVector,Austra.Library.DVector)</codeEntityReference> or <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Combine2(System.Double,System.Double,Austra.Library.DVector,Austra.Library.DVector)</codeEntityReference>. These methods are internally optimized to use a single temporary buffer, instead of the two buffers of a naïve implementation, and both of them use FMA fused operations when available. Of course, the method underlying the above presented <codeInline>vec::new</codeInline> constructor is even better optimized and runs several times faster than even the optimized versions of lineal composition.</para>
		    </content>
		  </section>
		  <section>
		    <title>Vector properties</title>
		    <content>
		      <para>Properties and methods or vectors are very similar to the ones from series. As a rule, almost all code in series that do not need to take dates into account, is implemented via the corresponding vector code, which is heavily optimized and hardware-accelerated. These are the properties supported by a vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>abs</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Abs</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>acf</codeInline></para></entry>
 		    	<entry><para>The AutoCorrelation Function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.ACF</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amax</codeInline></para></entry>
 		    	<entry><para>Gets the maximum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.AMax</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amin</codeInline></para></entry>
 		    	<entry><para>Gets the minimum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.AMin</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Distinct</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fft</codeInline></para></entry>
 		    	<entry><para>Gets the Fast Fourier Transform of the values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Fft</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.DVector.First</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.DVector.Last</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.DVector.Length</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Get the maximum value from the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Maximum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Mean</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Get the minimum value from the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Minimum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>norm</codeInline></para></entry>
 		    	<entry><para></para>Gets the Pythagorean norm of the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Norm</codeEntityReference>.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>pacf</codeInline></para></entry>
 		    	<entry><para>The Partial AutoCorrelation Function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.PACF</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>plot</codeInline></para></entry>
 		    	<entry><para>Shows the vector in a chart. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Plot</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Product</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Reverse</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sort</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with its items sorted. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Sort</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sortDesc</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with its items sorted in descending order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.SortDescending</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqr</codeInline></para></entry>
 		    	<entry><para>Gets the scalar product of the vector with itself. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Squared</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqrt</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the square root of each item. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Sqrt</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets all statistics in one call. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Stats</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Sum</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="vecmeths">
		    <title>Vector methods</title>
		    <content>
		      <para>These are the methods supported by a vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>all</codeInline></para></entry>
 		    	<entry><para>Checks if all items satisfy a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.All(System.Func{System.Double,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>any</codeInline></para></entry>
 		    	<entry><para>Checks if exists an item satisfying a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Any(System.Func{System.Double,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ar</codeInline></para></entry>
 		    	<entry><para>Gets the autoregression coefficients for a given <codeInline>p</codeInline>. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.AutoRegression(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>arModel</codeInline></para></entry>
 		    	<entry><para>Creates a full AR(p) model. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.ARModel(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>autocorr</codeInline></para></entry>
 		    	<entry><para>Gets the autocorrelation given a lag. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.AutoCorrelation(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>correlogram</codeInline></para></entry>
 		    	<entry><para>Gets all autocorrelations up to a given lag. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Correlogram(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>filter</codeInline></para></entry>
 		    	<entry><para>Filters items by value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Filter(System.Func{System.Double,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>find</codeInline></para></entry>
 		    	<entry><para>Similar to <codeInline>filter</codeInline>, but returns a sequence of the indexes. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Find(System.Double)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>indexOf</codeInline></para></entry>
 		    	<entry><para>Returns the first index where a value is stored. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.IndexOf(System.Double,System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linear</codeInline></para></entry>
 		    	<entry><para>Gets the regression coefficients given a list of vectors. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.LinearModel(Austra.Library.DVector[])</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>linearModel</codeInline></para></entry>
 		    	<entry><para>Creates a full linear model from a list of vectors. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.FullLinearModel(Austra.Library.DVector[])</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>ma</codeInline></para></entry>
 		    	<entry><para>Estimates coefficients for an MA(q) model. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.MovingAverage(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>maModel</codeInline></para></entry>
 		    	<entry><para>Creates a full MA(q) model. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.MAModel(System.Int32)</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>map</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items in a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Map(System.Func{System.Double,System.Double})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reduce</codeInline></para></entry>
 		    	<entry><para>Reduces all items in a vector to a single value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>zip</codeInline></para></entry>
 		    	<entry><para></para>Combines two vectors using a lambda function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.DVector.Zip(Austra.Library.DVector,System.Func{System.Double,System.Double,System.Double})</codeEntityReference>.</entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="vecOperators">
		    <title>Vector operators</title>
		    <content>
			  <para>Real-valued vectors supports the basic repertoire of operators:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>+</codeInline></para></entry>
 		    	  <entry><para>Adds two vectors, or a vector and a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>-</codeInline></para></entry>
 		    	  <entry><para>Subtracts two vectors, or a vector and a scalar. Also works as the unary negation.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>*</codeInline></para></entry>
 		    	  <entry><para>Multiplying two vectors represents the inner vector product, returning a number. A vector multiplied by a scalar is a vector scaling operation.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>/</codeInline></para></entry>
 		    	  <entry><para>Divides a vector by a scalar.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>.*</codeInline></para></entry>
 		    	  <entry><para>Pointwise vector multiplication.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>./</codeInline></para></entry>
 		    	  <entry><para>Pointwise vector division.</para></entry>
		  		</row>
 		  		<row>
 		    	  <entry><para><codeInline>^</codeInline></para></entry>
 		    	  <entry><para>Outer product for two vectors, returning a matrix.</para></entry>
		  		</row>
			  </table>
			  <para>The outer product of vectors <math>x[i]</math> and <math>y[i]</math> returns the matrix with components <math>m[i,j]=x[i]*y[j]</math>. This expression call:</para>
			  <code language="Austra">
[1,2,3]^[4,5,6]
			  </code>
			  <para>returns this matrix:</para>
			  <code language="Austra Desktop">
ans ∊ ℝ(3⨯3)
 4   5   6
 8  10  12
12  15  18
			  </code>
		    </content>
		  </section>
		</sections>
      </content>
    </section>
    <section address="cvecs">
      <title>Complex vectors</title>
      <content>
		<para>There's no special syntax for complex vector literals, but complex vectors can be easily created using the <codeInline>cvec::new</codeInline> class method and one or two vector constructors:</para>
        <code language="Austra">
<markup><b><font color="DarkCyan">cvec::</font></b></markup>new([1, 2, 3, 4], [4, 3, 2, 1]);
<markup><font color="DarkGreen">-- ::new can be omitted.</font></markup>
cvec([1, 2, 3, 4], [4, 3, 2, 1])
		</code>
		<para>These class methods are available for creating complex vectors:</para>
		<table>
 		  <row>
 		      <entry><para><codeInline>cvec::new</codeInline></para></entry>
			  <entry><para>Overloaded constructor (see below).</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>cvec::random</codeInline></para></entry>
 		    <entry><para>Creates a complex vector with random values from a uniform distribution.</para></entry>
		  </row>
 		  <row>
 		    <entry><para><codeInline>cvec::nrandom</codeInline></para></entry>
 		    <entry><para>Creates a complex vector with random values from a normal standard distribution.</para></entry>
		  </row>
		</table>
		<para>These are the overloads supported by <codeInline>cvec::new</codeInline>:</para>
        <code language="Austra">
<markup><font color="DarkGreen">-- Creates a complex vector with 10 zeros.</font></markup>
cvec(10);
<markup><font color="DarkGreen">-- Creates a complex vector from one real vector.</font></markup>
cvec([1, 2, 3]);
<markup><font color="DarkGreen">-- Creates a complex vector from two real vectors.</font></markup>
cvec([1, 2, 3], [3, 2, 1]);
<markup><font color="DarkGreen">-- Creates a complex vector with a lambda function.</font></markup>
cvec(10, i => polar(2π*i/10));
<markup><font color="DarkGreen">-- The lambda function includes access to the complex vector.</font></markup>
cvec(100, (i, v) => polar(2π*i/10) - 0.01 * i * v{i-1})
	    </code>
	    <sections>
		  <section address="cvecprop">
		    <title>Complex vector properties</title>
		    <content>
		      <para>These are the properties supported by a complex vector instance:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>amax</codeInline></para></entry>
 		    	<entry><para>Gets the maximum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.AbsMax</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>amin</codeInline></para></entry>
 		    	<entry><para>Gets the minimum of the absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.AbsMin</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Distinct</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>fft</codeInline></para></entry>
 		    	<entry><para>Gets the Fast Fourier Transform of the values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Fft</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.CVector.First</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>imag</codeInline></para></entry>
 		    	<entry><para>Gets the imaginary components as a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.CVector.Imaginary</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.CVector.Last</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.CVector.Length</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>magnitudes</codeInline></para></entry>
 		    	<entry><para>Gets magnitudes as a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Magnitudes</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mean</codeInline></para></entry>
 		    	<entry><para>Gets the average of the values in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Mean</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>norm</codeInline></para></entry>
 		    	<entry><para></para>Gets the Pythagorean norm of the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Norm</codeEntityReference>.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>phases</codeInline></para></entry>
 		    	<entry><para></para>Gets phases as a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Phases</codeEntityReference>.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>plot</codeInline></para></entry>
 		    	<entry><para>Shows the vector in a chart. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Plot</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Product</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>real</codeInline></para></entry>
 		    	<entry><para>Gets the real components as a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.CVector.Real</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Reverse</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sqr</codeInline></para></entry>
 		    	<entry><para>Gets the scalar product of the vector with itself. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Squared</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Sum</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  	<section aaddress="cvecmeth">
		      <title>Complex vector methods</title>
		    	<content>
		      	  <para>These are the methods supported by a complex vector instance:</para>
				  <table>
 		  	  		<row>
 		    		  <entry><para><codeInline>all</codeInline></para></entry>
 		    		  <entry><para>Checks if all items satisfy a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.All(System.Func{System.Numerics.Complex,System.Boolean})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>any</codeInline></para></entry>
 		    		  <entry><para>Checks if exists an item satisfying a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Any(System.Func{System.Numerics.Complex,System.Boolean})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>filter</codeInline></para></entry>
 		    		  <entry><para>Filters items by value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Filter(System.Func{System.Numerics.Complex,System.Boolean})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>find</codeInline></para></entry>
 		    		  <entry><para>Similar to <codeInline>filter</codeInline>, but returns a sequence of the indexes. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Find(System.Numerics.Complex)</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>indexOf</codeInline></para></entry>
 		    		  <entry><para>Returns the first index where a value is stored. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.IndexOf(System.Numerics.Complex)</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>map</codeInline></para></entry>
 		    		  <entry><para>Pointwise transformation of the items in a vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Map(System.Func{System.Numerics.Complex,System.Numerics.Complex})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>mapReal</codeInline></para></entry>
 		    		  <entry><para>Pointwise transformation of the items in a vector. Returns a real vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.MapReal(System.Func{System.Numerics.Complex,System.Double})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>reduce</codeInline></para></entry>
 		    		  <entry><para>Reduces all items in a vector to a single value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Reduce(System.Numerics.Complex,System.Func{System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex})</codeEntityReference>.</para></entry>
		  	  		</row>
 		  	  		<row>
 		    		  <entry><para><codeInline>zip</codeInline></para></entry>
 		    		  <entry><para></para>Combines two vectors using a lambda function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.CVector.Zip(Austra.Library.CVector,System.Func{System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex})</codeEntityReference>.</entry>
		  	  		</row>
				  </table>
			</content>
		  </section>
		  <section address="cvecOperators">
		    <title>Complex vector operators</title>
		    <content>
			  <para>Complex vectors supports the same operators as real-valued operators, with the exception of the outer product <codeInline>^</codeInline>. On the other hand, they add support for complex vector conjugation using a unary suffix operator:</para>
			  <table>
 		  		<row>
 		    	  <entry><para><codeInline>'</codeInline></para></entry>
 		    	  <entry><para>Unary suffix operator for complex vector conjugation.</para></entry>
		  		</row>
			  </table>
			  <para>Complex vector conjugation inverts the sign of each imaginary component in the vector. The inner product of two complex vectors actually conjugates the second vector operand.</para>
		    </content>
		  </section>
	    </sections>
	  </content>
    </section>
    <section address="ivecs">
      <title>Integer vectors</title>
      <content>
        <para>Integer vectors are also supported, using the <codeInline>ivec</codeInline> class.</para>
	    <table>
  		  <row>
    	    <entry><para><codeInline>ivec::new</codeInline></para></entry>
    	    <entry><para>Overloaded constructor.</para></entry>
  		  </row>
  		  <row>
    	    <entry><para><codeInline>ivec::ones</codeInline></para></entry>
    	    <entry><para>Creates a vector filled with ones.</para></entry>
  		  </row>
  		  <row>
    	    <entry><para><codeInline>ivec::random</codeInline></para></entry>
    	    <entry><para>Creates a vector with random values from a uniform distribution.</para></entry>
  		  </row>
	    </table>
        <para><codeInline>ivec::random</codeInline> has three overloaded variants:</para>
		<code language="Austra">
<markup><font color="DarkGreen">-- Ten items. Values between <codeInline>0</codeInline> and <codeInline>int.MaxValue - 1</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(10);
<markup><font color="DarkGreen">-- Values between <codeInline>0</codeInline> and <codeInline>999</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(10, 1000);
<markup><font color="DarkGreen">-- Values between <codeInline>-10</codeInline> and <codeInline>9</codeInline>.</font><br/>
<b><font color="DarkCyan">ivec::</font></b></markup>random(-10, 10)
		</code>
		<sections>
		  <section address="ivecprop">
		    <title>Integer vector properties</title>
		    <content>
		    <para>Integer vectors support these properties:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>abs</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with absolute values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Abs</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>distinct</codeInline></para></entry>
 		    	<entry><para>Gets a new vector with the unique values from the original one. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Distinct</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>first</codeInline></para></entry>
 		    	<entry><para>Gets the first item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.NVector.First</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>last</codeInline></para></entry>
 		    	<entry><para>Gets the last item in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.NVector.Last</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry><para>Gets the number of values in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">P:Austra.Library.NVector.Length</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>max</codeInline></para></entry>
 		    	<entry><para>Gets the maximum value from the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Maximum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>min</codeInline></para></entry>
 		    	<entry><para>Gets the minimum values from the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Minimum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>prod</codeInline></para></entry>
 		    	<entry><para>Multiplies all items in the vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Product</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reverse</codeInline></para></entry>
 		    	<entry><para>Creates a new vector with items in reverse order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Reverse</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sort</codeInline></para></entry>
 		    	<entry><para>Sorts the vector in ascending order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Sort</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sortDesc</codeInline></para></entry>
 		    	<entry><para>Sorts the vector in descending order. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.SortDescending</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>stats</codeInline></para></entry>
 		    	<entry><para>Gets all statistics in one call. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Stats</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>sum</codeInline></para></entry>
 		    	<entry><para>Gets the sum of all values. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Sum</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>toVector</codeInline></para></entry>
 		    	<entry><para>Converts the integer vector into a double vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.ToVector</codeEntityReference>.</para></entry>
		  	  </row>
			</table>
			</content>
		  </section>
		  <section address="ivecmth">
		    <title>Integer vector methods</title>
		    <content>
		    <para>These are the methods for integer vectors:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>all</codeInline></para></entry>
 		    	<entry><para>Checks if all items satisfy a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.All(System.Func{System.Int32,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>any</codeInline></para></entry>
 		    	<entry><para>Checks if exists an item satisfying a lambda predicate. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Any(System.Func{System.Int32,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>filter</codeInline></para></entry>
 		    	<entry><para>Filters items by value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Filter(System.Func{System.Int32,System.Boolean})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>map</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items in another integer vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Map(System.Func{System.Int32,System.Int32})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>mapReal</codeInline></para></entry>
 		    	<entry><para>Pointwise transformation of the items into a real vector. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.MapReal(System.Func{System.Int32,System.Double})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>reduce</codeInline></para></entry>
 		    	<entry><para>Reduces all items in a vector to a single integer value. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Reduce(System.Int32,System.Func{System.Int32,System.Int32,System.Int32})</codeEntityReference>.</para></entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>zip</codeInline></para></entry>
 		    	<entry><para></para>Combines two integer vectors using a lambda function. See <codeEntityReference qualifyHint="false" autoUpgrade="true">M:Austra.Library.NVector.Zip(Austra.Library.NVector,System.Func{System.Int32,System.Int32,System.Int32})</codeEntityReference>.</entry>
		  	  </row>
			</table>
			</content>
		  </section>
		</sections>
      </content>
    </section>
    <section address="vecidx">
      <title>Indexing and slicing</title>
      <content>
		<para>Individual values from vectors are accessed using its position, starting from zero, inside brackets:</para>
		<code language="Austra">
vec[0];
vec[vec.length - 1]
		</code>
		<para>A segment or slice can be extracted as another vector by using this notation:</para>
		<code language="Austra">
vec[1..vec.length - 1]
		</code>
		<para>The above expression removes the first and the last element from a vector. The upper bound is excluded.</para>
		<para>The caret (<codeInline>^</codeInline>) can be used in indexes and segments, to count positions from the end. For instance, this expression returns the next to last item of a vector:</para>
		<code language="Austra">
vec[^1]
		</code>
		<para>These equalities hold:</para>
		<code language="Austra">
vec[1..^1] = vec[1..vec.length - 1];
vec[^5..^2].length = 3
		</code>
		<para>Vectors and series also support safe indexers. With normal indexers, like <codeInline>v[1000]</codeInline>, an out-of-range reference throws an exception and interrupts the evaluation of the
		formula. If braces are used instead of brackets, and out-of-range reference returns 0.0 and it is considered as a valid use. For instance, the following expression returns zero:</para>
		<code language="Austra">
[1, 2, 3, 4]{1000}
		</code>
		<para>Safe indexers are useful when used inside lambda functions. This expression creates a vector holding the first 30 Fibonacci numbers:</para>
		<code language="Austra">
		vec(30, (i, v) => max(1, v{i-1} + v{i-2}))
		</code>
      </content>
    </section>
    <section address="vecfft">
      <title>The Fast Fourier Transform</title>
      <content>
		<para>AUSTRA provides a Discrete Fourier Transform for real and complex vectors, sequences, and series. The core result of the transformation, which is implemented by the <codeInline>fft</codeInline> property is a complex vector, but this vector is commonly wrapped inside a <codeInline>FftModel</codeInline> class instance, which provides additional helping methods and properties and, among them, a method for inverting the transform and getting back the original samples.</para>
		<para>The other function of <codeInline>FftModel</codeInline> is to act a semantic marker on behalf of any application that is using the AUSTRA parser. When you execute something like <codeInline>aaa.fft</codeInline> in the Austra Desktop application, where <codeInline>aaa</codeInline> is a time series, you get a special view for the Fast Fourier Transform based on the returned <codeInline>FftModel</codeInline>:</para>
        <mediaLink>
			<image placement="near" xlink:href="fft1"/>
		</mediaLink>
		<para>The first line tells us we are seeing a Fast Fourier Transform that has transformed 583 real samples into a complex spectrum containing 291 complex values. Since there is not a pretty and effective way to draw those complex values, the chart that follows shows the amplitudes of those values, and gives us the option to also see their phases.</para>
		<para>If we immediately type and execute <codeInline>ans.inverse</codeInline>, we would get not the original series, because the date arguments has been discarded by the FFT, but a vector with the original values or coordinates of the time series. The key in the recon-struction is that the <codeInline>FftModel</codeInline> keeps track of the fact that the FFT was created from a vector of reals instead of from a vector of complex numbers.</para>
		<para>Let us check now how our FFT handles a complex vector. For making things a little more interesting this time, we are going to start with this formula:</para>
		<code language="Austra">
(<markup><b><font color="DarkCyan">cvec::</font></b></markup>nrandom(1024) + cvec(1024, i => 0.6*sin(i*0.2))).fft
		</code>
		<para>There is a noisy component, based on a normal distribution, and then we add a shameless periodic function, affecting just the real part of the complex vector. The first thing we can predict is that the FFT will not have a big zero component: the zero component of any Discrete Fourier Transform is known as the DC, or Direct Current component, in electronic jargon, because it represents the mean of the samples. Our new mean will be insignificant, because the normal distribution generates both positive and negative terms, and the corresponding plot confirms our suspicions:</para>
        <mediaLink>
			<image placement="near" xlink:href="fft2"/>
		</mediaLink>
		<para>This time, the number of samples in the transform is the same number of original samples. It is immediately obvious that there is a periodic component in the samples, which shows as two symmetric peaks at the beginning and end of the spectrum. And, if we immediately execute <codeInline>ans.inverse</codeInline>, we get back the original complex vector, with all its samples.</para>
		<sections>
		  <section address="fftProps">
		    <title>FFT properties and indexer</title>
		    <content>
		    <para>For the sake of clarity, let us group all properties available for FFT models:</para>
			<table>
 		  	  <row>
 		    	<entry><para><codeInline>amplitudes</codeInline></para></entry>
 		    	<entry>Gets the amplitudes, or magnitudes, of the transformation numbers.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>inverse</codeInline></para></entry>
 		    	<entry>Performs the inverse transformation for the full spectrum. The algorithm used depends on the kind of source of the transformation.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>length</codeInline></para></entry>
 		    	<entry>Number of samples in the transformation result.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>phases</codeInline></para></entry>
 		    	<entry>Gets the phases of the transformation numbers.</entry>
		  	  </row>
 		  	  <row>
 		    	<entry><para><codeInline>values</codeInline></para></entry>
 		    	<entry>The full spectrum of the transformation, as a complex vector.</entry>
		  	  </row>
			</table>
			<para>The <codeInline>FftModel</codeInline> class also implements an indexer and allows the use of slices and relative indexes.</para>
		    </content>
		  </section>
		</sections>
      </content>
    </section>
    <relatedTopics>
	  <link xlink:href="90cb2899-abcf-4ebe-b96a-8cfac1b2809f">Code definitions</link>
      <link xlink:href="8b381718-bf08-4762-a51b-1516af27bef2">Local variables</link>
      <link xlink:href="9ebcc778-37a1-4313-87f9-1ea37494d2c8">Lambda functions</link>
      <link xlink:href="e22b4127-e7a9-47ca-bd1c-7ac81efcc051">Arithmetic</link>
      <link xlink:href="1800e13a-baf2-48f8-aefa-746082fe23df">Time series</link>
      <link xlink:href="d1757dd1-7bbd-4d90-88b9-cc034c5ad326">Sequences</link>
      <link xlink:href="e9d3be4d-ac7d-4b8e-b892-c47a5a0beb49">Matrices</link>
      <link xlink:href="95cad3a9-e319-4787-a66b-596e34e6ddd6">List comprehensions</link>
      <link xlink:href="008dce7e-55cd-4c37-997b-b0463d7c24d0">Splines</link>
      <codeEntityReference qualifyHint="false">T:Austra.Library.DVector</codeEntityReference>
      <codeEntityReference qualifyHint="false">T:Austra.Library.CVector</codeEntityReference>
      <codeEntityReference qualifyHint="false">T:Austra.Library.NVector</codeEntityReference>
    </relatedTopics>
  </developerConceptualDocument>
</topic>